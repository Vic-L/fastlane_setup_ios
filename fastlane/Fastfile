update_fastlane

fastlane_version "2.26.1"

default_platform :ios

platform :ios do
  before_all do
    xcode_select ENV["DEVELOPER_DIR"]
    cocoapods
    ENV['FASTLANE_DONT_STORE_PASSWORD']="1" # dont store pw in keychain
  end

  ["staging", "uat"].each do |env|
    lane env.to_sym do
      ENV['FASTLANE_PASSWORD']=ENV["#{env.upcase}_APPLE_ID_PASSWORD"]

      match(
        git_url: ENV['CERTS_GIT_URL'],
        type: "enterprise"
      )

      pem(
        development: true, # default false
        generate_p12: true,
        force: false,
        save_private_key: false, # default true
        output_path: "./fastlane",
        p12_password: ENV["#{env.upcase}_P12_PASSWORD"]
      )

      cert(
        username: CredentialsManager::AppfileConfig.try_fetch_value(:apple_id),
        team_id: CredentialsManager::AppfileConfig.try_fetch_value(:team_id),
        team_name: CredentialsManager::AppfileConfig.try_fetch_value(:team_name),
        output_path: "./fastlane",
        development: true,
      )

      sigh(
        skip_install: false,
        app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier),
        username: CredentialsManager::AppfileConfig.try_fetch_value(:apple_id),
        team_id: CredentialsManager::AppfileConfig.try_fetch_value(:team_id),
        cert_id: ENV["#{env.upcase}_CERT_ID"],
        platform: "ios",
        output_path: "./fastlane",
        # development: true,
        # force: true, # uncomment to recreate provisioning profile on build

        # skip_fetch_profiles: false,
        # skip_certificate_verification: false,
        # adhoc: false,
        # ignore_profiles_with_different_name: false,
      )

      ## NOTE: comment `update_settings_bundle` functions below if no Settings.bundle
      update_settings_bundle(
        key: "appVersion",
        value: ":version (:build)",
        target: ENV["#{env.upcase}_SCHEME"]
      )

      update_settings_bundle(
        key: "buildTimestamp",
        value: Time.now.strftime('%a, %e %b %Y %H:%M %p'),
        target: ENV["#{env.upcase}_SCHEME"]
      )

      gym(
        scheme: ENV["#{env.upcase}_SCHEME"],
        workspace: ENV["#{env.upcase}_WORKSPACE"],
        output_name: ENV["#{env.upcase}_OUTPUT_NAME"],
        clean: true,
        output_directory: ".",
        silent: false,
        buildlog_path: "~/Library/Logs/gym",
        # export_method: "development",

        # destination: "generic/platform=iOS",
        # use_legacy_build_api: "false",
      )

      aws_s3(
        # All of these are used to make Shenzhen's `ipa distribute:s3` command
        access_key: ENV["#{env.upcase}_S3_ACCESS_KEY"],
        secret_access_key: ENV["#{env.upcase}_S3_SECRET_ACCESS_KEY"],
        bucket: ENV["#{env.upcase}_S3_BUCKET"],
        region: ENV["#{env.upcase}_S3_REGION"],
        ipa: ENV["#{env.upcase}_IPA"],                     # Required (if not uploading an APK).
        app_directory: ENV["#{env.upcase}_APP_DIRECTORY"], # Optional but nice if you want to put multiple apps in same bucket
        path: '',                                    # default will create alot of files: 'v{CFBundleShortVersionString}_b{CFBundleVersion}/'

        # upload_metadata: true,                     # Upload version.json, plist and HTML. Set to false to skip uploading of these files.
        # version_file_name: 'app_version.json',     # Name of the file to upload to S3. Defaults to 'version.json'
        # version_template_path: 'path/to/erb'       # Path to an ERB to configure the structure of the version JSON file
        # apk: 'AppName.apk',                        # Required (if not uploading an IPA).
        # dsym: 'AppName.app.dSYM.zip',              # Optional is you use `ipa` to build.
      )

      # pilot

      slack(
        message: "#{ENV['SLACK_MENTION']} new *#{env.upcase}* build *#{Time.now.strftime('%a, %e %b %Y %H:%M %p')}* @ https://www.codigo.co/codigo-builds/#{ENV["#{env.upcase}_APP_DIRECTORY"]}/index.html",
        channel: ENV['SLACK_CHANNEL']
      )
    end
  end

  error do |lane, exception|
    # slack(
    #   message: exception.message,
    #   success: false
    # )
  end
end